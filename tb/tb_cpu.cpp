// tb/tb_cpu.cpp

#include "verilated.h"
#include "verilated_vcd_c.h"
#include "Vtb_cpu.h"   // generated by Verilator

// global time variable
static vluint64_t main_time = 0;

// tell Verilator how to handle $time in your SV
double sc_time_stamp() {
    return main_time;
}

int main(int argc, char **argv) {
    // pass command‑line args into Verilator
    Verilated::commandArgs(argc, argv);

    // instantiate the DUT
    Vtb_cpu* dut = new Vtb_cpu;

    // enable waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    dut->trace(tfp, 99);              // you can reduce trace levels if you like
    tfp->open("tb_cpu.vcd");

    // apply reset for two full cycles
    dut->reset = 1;
    dut->clk   = 0;
    for (int i = 0; i < 4; i++) {
        dut->eval();
        tfp->dump(main_time++);
        dut->clk = !dut->clk;
    }
    dut->reset = 0;

    // run for N more cycles
    const vluint64_t MAX_CYCLES = 500;  
    for (vluint64_t cycle = 0; cycle < MAX_CYCLES; cycle++) {
        // half‑cycle: clock low
        dut->clk = 0;
        dut->eval();
        tfp->dump(main_time++);

        // half‑cycle: clock high
        dut->clk = 1;
        dut->eval();
        tfp->dump(main_time++);
    }

    // clean up
    tfp->close();
    delete dut;
    delete tfp;
    return 0;
}
